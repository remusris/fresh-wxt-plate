Welcome to WXT!
WXT is a modern, open-source framework for building web extensions. Inspired by Nuxt, its goals are to:

Provide an awesome DX
Provide first-class support for all major browsers
Check out the comparison to see how WXT compares to other tools for building web extensions.

Prerequisites
These docs assume you have a basic knowledge of how Chrome extensions are structured and how you access the extension APIs.

New to extension development?

If you have never written an extension before, follow Chrome's Hello World tutorial to first create an extension without WXT, then come back here.

You should also be aware of Chrome's extension docs and Mozilla's extension docs. WXT does not change how you use the extension APIs, and you'll need to refer to these docs often when using specific APIs.



Alright, got a basic understanding of how web extensions are structured? Do you know how to access the extension APIs? Then continue to the Installation page to create your first WXT extension.

Installation
Bootstrap a new project, start from scratch, or migrate an existing project.

Bootstrap Project
Demo
From Scratch
Next Steps
Bootstrap Project
Run the init command, and follow the instructions.


PNPM

Bun

NPM

Yarn

pnpm dlx wxt@latest init
Starter Templates:

TypeScript LogoVanilla
Vue LogoVue
React LogoReact
Svelte LogoSvelte
Solid LogoSolid

All templates use TypeScript by default. To use JavaScript, change the file extensions.

Demo
wxt init demo

Once you've run the dev command, continue to Next Steps!

From Scratch
Create a new project

PNPM

Bun

NPM

Yarn

cd my-project
pnpm init
Install WXT:

PNPM

Bun

NPM

Yarn

pnpm i -D wxt
Add an entrypoint, my-project/entrypoints/background.ts:

ts

export default defineBackground(() => {
  console.log('Hello world!');
});
Add scripts to your package.json:

{
  "scripts": {
    "dev": "wxt", 
    "dev:firefox": "wxt -b firefox", 
    "build": "wxt build", 
    "build:firefox": "wxt build -b firefox", 
    "zip": "wxt zip", 
    "zip:firefox": "wxt zip -b firefox", 
    "postinstall": "wxt prepare"
  }
}
Run your extension in dev mode

PNPM

Bun

NPM

Yarn

pnpm dev
WXT will automatically open a browser window with your extension installed.
Next Steps
Keep reading on about WXT's Project Structure and other essential concepts to learn
Configure automatic browser startup during dev mode
Explore WXT's example library to see how to use specific APIs or perform common tasks

Project Structure
WXT follows a strict project structure. By default, it's a flat folder structure that looks like this:


📂 {rootDir}/
   📁 .output/
   📁 .wxt/
   📁 assets/
   📁 components/
   📁 composables/
   📁 entrypoints/
   📁 hooks/
   📁 modules/
   📁 public/
   📁 utils/
   📄 .env
   📄 .env.publish
   📄 app.config.ts
   📄 package.json
   📄 tsconfig.json
   📄 web-ext.config.ts
   📄 wxt.config.ts
Here's a brief summary of each of these files and directories:

.output/: All build artifacts will go here
.wxt/: Generated by WXT, it contains TS config
assets/: Contains all CSS, images, and other assets that should be processed by WXT
components/: Auto-imported by default, contains UI components
composables/: Auto-imported by default, contains composable functions for Vue
entrypoints/: Contains all the entrypoints that get bundled into your extension
hooks/: Auto-imported by default, contains hooks for React and Solid
public/: Contains any files you want to copy into the output folder as-is, without being processed by WXT
utils/: Auto-imported by default, contains generic utilities used throughout your project
.env: Contains Environment Variables
.env.publish: Contains Environment Variables for publishing
app.config.ts: Contains Runtime Config
package.json: The standard file used by your package manager
tsconfig.json: Config telling TypeScript how to behave
web-ext.config.ts: Configure Browser Startup
wxt.config.ts: The main config file for WXT projects
Adding a src/ Directory
Many developers like having a src/ directory to separate source code from configuration files. You can enable it inside the wxt.config.ts file:


// wxt.config.ts
export default defineConfig({
  srcDir: 'src',
});
After enabling it, your project structure should look like this:


📂 {rootDir}/
📁 .output/
📁 .wxt/
📂 src/
   📁 assets/
   📁 components/
   📁 composables/
   📁 entrypoints/
   📁 hooks/
   📁 modules/
   📁 public/
   📁 utils/
   📄 app.config.ts
📄 .env
📄 .env.publish
📄 package.json
📄 tsconfig.json
📄 web-ext.config.ts
📄 wxt.config.ts
Customizing Other Directories
You can configure the following directories:


// wxt.config.ts
export default defineConfig({
  // Relative to project root
  srcDir: "src",             // default: "."
  outDir: "dist",            // default: ".output"

  // Relative to srcDir
  entrypointsDir: "entries", // default: "entrypoints"
  modulesDir: "wxt-modules", // default: "modules"
  publicDir: "static",       // default: "public"
})
You can use absolute or relative paths

Entrypoints
WXT uses the files inside the entrypoints/ directory as inputs when bundling your extension. They can be HTML, JS, CSS, or any variant of those file types supported by Vite (Pug, TS, JSX, SCSS, etc).

Here's an example set of entrypoints:


📂 entrypoints/
   📂 popup/
      📄 index.html
      📄 main.ts
      📄 style.css
   📄 background.ts
   📄 content.ts
Listed vs Unlisted
Adding Entrypoints
Defining Manifest Options
Entrypoint Types
Background
Bookmarks
Content Scripts
Devtools
History
Newtab
Options
Popup
Sandbox
Side Panel
Unlisted CSS
Unlisted Pages
Unlisted Scripts
Listed vs Unlisted
For web extensions, there are two types of entrypoints:

Listed: Referenced in the manifest.json
Unlisted: Not referenced in the manifest.json
Throughout the rest of WXT's documentation, listed files are referred to by name. For example:

Popup
Options
Background
Content Scripts
Etc.
Some examples of "unlisted" entrypoints:

A welcome page shown when the extension is installed
JS files injected by content scripts into the page's main world
TIP

Regardless of whether a entrypoint is listed or unlisted, it will still be bundled into your extension and be available at runtime.

Adding Entrypoints
An entrypoint can be defined as a single file or directory with an index file inside it.


Single File

Directory

📂 entrypoints/
   📄 background.ts
The entrypoint's name dictates the type of entrypoint, listed vs unlisted. In this example, "background" is the name of the "Background" entrypoint.

Refer to the Entrypoint Types section for the full list of listed entrypoints and their filename patterns.

Defining Manifest Options
Most listed entrypoints have options that need to be added to the manifest.json. With WXT however, instead of defining the options in a separate file, you define these options inside the entrypoint file itself.

For example, here's how to define matches for content scripts:


// entrypoints/content.ts
export default defineContentScript({
  matches: ['*://*.wxt.dev/*'],
  main() {
    // ...
  },
});
Refer to the Entrypoint Types sections for a list of options configurable inside each entrypoint, and how to define them.

When building your extension, WXT will look at the options defined in your entrypoints, and generate the manifest accordingly.

Entrypoint Types
Background
Chrome Docs • Firefox Docs

For MV2, the background is added as a script to the background page. For MV3, the background becomes a service worker.

Filename		Output Path
entrypoints/background.[jt]s		/background.js
entrypoints/background/index.[jt]s		/background.js

Minimal

With Manifest Options

export default defineBackground(() => {
  // Executed when background is loaded
});
Bookmarks
Chrome Docs • Firefox Docs

Filename		Output Path
entrypoints/bookmarks.html		/bookmarks.html
entrypoints/bookmarks/index.html		/bookmarks.html

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Title</title>
    <!-- Set include/exclude if the page should be removed from some builds -->
    <meta name="manifest.include" content="['chrome', ...]" />
    <meta name="manifest.exclude" content="['chrome', ...]" />
  </head>
  <body>
    <!-- ... -->
  </body>
</html>
Content Scripts
Chrome Docs • Firefox Docs

See Content Script UI for more info on creating UIs and including CSS in content scripts.

Filename		Output Path
entrypoints/content.[jt]sx?		/content-scripts/content.js
entrypoints/content/index.[jt]sx?		/content-scripts/content.js
entrypoints/<name>.content.[jt]sx?		/content-scripts/<name>.js
entrypoints/<name>.content/index.[jt]sx?		/content-scripts/<name>.js

export default defineContentScript({
  // Set manifest options
  matches: string[],
  excludeMatches: undefined | [],
  includeGlobs: undefined | [],
  excludeGlobs: undefined | [],
  allFrames: undefined | true | false,
  runAt: undefined | 'document_start' | 'document_end' | 'document_idle',
  matchAboutBlank: undefined | true | false,
  matchOriginAsFallback: undefined | true | false,
  world: undefined | 'ISOLATED' | 'MAIN',

  // Set include/exclude if the background should be removed from some builds
  include: undefined | string[],
  exclude: undefined | string[],

  // Configure how CSS is injected onto the page
  cssInjectionMode: undefined | "manifest" | "manual" | "ui",

  // Configure how/when content script will be registered
  registration: undefined | "manifest" | "runtime",

  main(ctx: ContentScriptContext) {
    // Executed when content script is loaded, can be async
  },
});
Devtools
Chrome Docs • Firefox Docs

Follow the Devtools Example to add different panels and panes.

Filename		Output Path
entrypoints/devtools.html		/devtools.html
entrypoints/devtools/index.html		/devtools.html

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Set include/exclude if the page should be removed from some builds -->
    <meta name="manifest.include" content="['chrome', ...]" />
    <meta name="manifest.exclude" content="['chrome', ...]" />
  </head>
  <body>
    <!-- ... -->
  </body>
</html>
History
Chrome Docs • Firefox Docs

Filename		Output Path
entrypoints/history.html		/history.html
entrypoints/history/index.html		/history.html

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Title</title>
    <!-- Set include/exclude if the page should be removed from some builds -->
    <meta name="manifest.include" content="['chrome', ...]" />
    <meta name="manifest.exclude" content="['chrome', ...]" />
  </head>
  <body>
    <!-- ... -->
  </body>
</html>
Newtab
Chrome Docs • Firefox Docs

Filename		Output Path
entrypoints/newtab.html		/newtab.html
entrypoints/newtab/index.html		/newtab.html

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Title</title>
    <!-- Set include/exclude if the page should be removed from some builds -->
    <meta name="manifest.include" content="['chrome', ...]" />
    <meta name="manifest.exclude" content="['chrome', ...]" />
  </head>
  <body>
    <!-- ... -->
  </body>
</html>
Options
Chrome Docs • Firefox Docs

Filename		Output Path
entrypoints/options.html		/options.html
entrypoints/options/index.html		/options.html

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Options Title</title>
    <meta name="manifest.open_in_tab" content="true|false" />
    <meta name="manifest.chrome_style" content="true|false" />
    <meta name="manifest.browser_style" content="true|false" />
    <!-- Set include/exclude if the page should be removed from some builds -->
    <meta name="manifest.include" content="['chrome', ...]" />
    <meta name="manifest.exclude" content="['chrome', ...]" />
  </head>
  <body>
    <!-- ... -->
  </body>
</html>
Popup
Chrome Docs • Firefox Docs

Filename		Output Path
entrypoints/popup.html		/popup.html
entrypoints/popup/index.html		/popup.html

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Default Popup Title</title>
    <meta
      name="manifest.default_icon"
      content="{
        16: '/icon-16.png',
        24: '/icon-24.png',
        ...
      }"
    />
    <meta name="manifest.type" content="page_action|browser_action" />
    <meta name="manifest.browser_style" content="true|false" />
    <!-- Set include/exclude if the page should be removed from some builds -->
    <meta name="manifest.include" content="['chrome', ...]" />
    <meta name="manifest.exclude" content="['chrome', ...]" />
  </head>
  <body>
    <!-- ... -->
  </body>
</html>
Sandbox
Chrome Docs

Chromium Only

Firefox does not support sandboxed pages.

Filename		Output Path
entrypoints/sandbox.html		/sandbox.html
entrypoints/sandbox/index.html		/sandbox.html
entrypoints/<name>.sandbox.html		/<name>.html
entrypoints/<name>.sandbox/index.html		/<name>.html

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Title</title>
    <!-- Set include/exclude if the page should be removed from some builds -->
    <meta name="manifest.include" content="['chrome', ...]" />
    <meta name="manifest.exclude" content="['chrome', ...]" />
  </head>
  <body>
    <!-- ... -->
  </body>
</html>
Side Panel
Chrome Docs • Firefox Docs

In Chrome, side panels use the side_panel API, while Firefox uses the sidebar_action API.

Filename		Output Path
entrypoints/sidepanel.html		/sidepanel.html
entrypoints/sidepanel/index.html		/sidepanel.html
entrypoints/<name>.sidepanel.html		/<name>.html`
entrypoints/<name>.sidepanel/index.html		/<name>.html`

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Default Side Panel Title</title>
    <meta
      name="manifest.default_icon"
      content="{
        16: '/icon-16.png',
        24: '/icon-24.png',
        ...
      }"
    />
    <meta name="manifest.open_at_install" content="true|false" />
    <meta name="manifest.browser_style" content="true|false" />
    <!-- Set include/exclude if the page should be removed from some builds -->
    <meta name="manifest.include" content="['chrome', ...]" />
    <meta name="manifest.exclude" content="['chrome', ...]" />
  </head>
  <body>
    <!-- ... -->
  </body>
</html>
Unlisted CSS
Follow Vite's guide to setup your preprocessor of choice: https://vitejs.dev/guide/features.html#css-pre-processors

CSS entrypoints are always unlisted. To add CSS to a content script, see the Content Script docs.

Filename		Output Path
entrypoints/<name>.(css|scss|sass|less|styl|stylus)		/<name>.css
entrypoints/<name>/index.(css|scss|sass|less|styl|stylus)		/<name>.css
entrypoints/content.(css|scss|sass|less|styl|stylus)		/content-scripts/content.css
entrypoints/content/index.(css|scss|sass|less|styl|stylus)		/content-scripts/content.css
entrypoints/<name>.content.(css|scss|sass|less|styl|stylus)		/content-scripts/<name>.css
entrypoints/<name>.content/index.(css|scss|sass|less|styl|stylus)		/content-scripts/<name>.css

body {
  /* ... */
}
Unlisted Pages
Filename		Output Path
entrypoints/<name>.html		/<name>.html
entrypoints/<name>/index.html		/<name>.html

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Title</title>
    <!-- Set include/exclude if the page should be removed from some builds -->
    <meta name="manifest.include" content="['chrome', ...]" />
    <meta name="manifest.exclude" content="['chrome', ...]" />
  </head>
  <body>
    <!-- ... -->
  </body>
</html>
Pages are accessible at /<name>.html:


const url = browser.runtime.getURL('/<name>.html');

console.log(url); // "chrome-extension://<id>/<name>.html"
Unlisted Scripts
Filename		Output Path
entrypoints/<name>.[jt]sx?		/<name>.js
entrypoints/<name>/index.[jt]sx?		/<name>.js

Minimal

With Options

export default defineUnlistedScript(() => {
  // Executed when script is loaded
});
Scripts are accessible from /<name>.js:


const url = browser.runtime.getURL('/<name>.js');

console.log(url); // "chrome-extension://<id>/<name>.js"
You are responsible for loading/running these scripts where needed. If necessary, don't forget to add the script and/or any related stylesheets to web_accessible_resources.

Manifest
In WXT, there is no manifest.json file in your source code. Instead, WXT generates it during the build process based off files in your project.

Manifest Config
To manually add a property to the manifest.json output during builds, use the manifest config inside wxt.config.ts:


export default defineConfig({
  manifest: {
    // Put manual changes here
  },
});
You can also define the manifest as a function, and use JS to generate it based on the target browser, mode, and more.


export default defineConfig({
  manifest: ({ browser, manifestVersion, mode, command }) => {
    return {
      // ...
    };
  },
});
MV2 and MV3 Compatibility
When adding properties to the manifest, always define the property in it's MV3 format when possible. When targeting MV2, WXT will automatically convert these properties to their MV2 format.

For example, for this config:


export default defineConfig({
  manifest: {
    action: {
      default_title: 'Some Title',
    },
    web_accessible_resources: [
      {
        matches: ['*://*.google.com/*'],
        resources: ['icon/*.png'],
      },
    ],
  },
});
WXT will generate the following manifests:


MV2

MV3

{
  "manifest_version": 2,
  // ...
  "browser_action": {
    "default_title": "Some Title"
  },
  "web_accessible_resources": ["icon/*.png"]
}
You can also specify properties specific to a single manifest version, and they will be stripped out when targeting the other manifest version.

Name
Chrome Docs

If not provided via the manifest config, the manifest's name property defaults to your package.json's name property.

Version and Version Name
Chrome Docs

Your extension's version and version_name is based on the version from your package.json.

version_name is the exact string listed
version is the string cleaned up, with any invalid suffixes removed
Example:


// package.json
{
  "version": "1.3.0-alpha2"
}

// .output/<target>/manifest.json
{
  "version": "1.3.0",
  "version_name": "1.3.0-alpha2"
}
If a version is not present in your package.json, it defaults to "0.0.0".

Icons
WXT automatically discovers your extension's icon by looking at files in the public/ directory:


public/
├─ icon-16.png
├─ icon-24.png
├─ icon-48.png
├─ icon-96.png
└─ icon-128.png
Specifically, if an icon must match one of these regex to be discovered:


const iconRegex = [
  /^icon-([0-9]+)\.png$/,                 // icon-16.png
  /^icon-([0-9]+)x[0-9]+\.png$/,          // icon-16x16.png
  /^icon@([0-9]+)w\.png$/,                // icon@16w.png
  /^icon@([0-9]+)h\.png$/,                // icon@16h.png
  /^icon@([0-9]+)\.png$/,                 // icon@16.png
  /^icons?[/\\]([0-9]+)\.png$/,          // icon/16.png | icons/16.png
  /^icons?[/\\]([0-9]+)x[0-9]+\.png$/,   // icon/16x16.png | icons/16x16.png
];
If you don't like these filename or you're migrating to WXT and don't want to rename the files, you can manually specify an icon in your manifest:


export default defineConfig({
  manifest: {
    icons: {
      16: '/extension-icon-16.png',
      24: '/extension-icon-24.png',
      48: '/extension-icon-48.png',
      96: '/extension-icon-96.png',
      128: '/extension-icon-128.png',
    },
  },
});
Alternatively, you can use @wxt-dev/auto-icons to let WXT generate your icon at the required sizes.

Permissions
Chrome docs


export default defineConfig({
  manifest: {
    permissions: ['storage', 'tabs'],
  },
});
Host Permissions
Chrome docs


export default defineConfig({
  manifest: {
    permissions: ['storage', 'tabs'],
  },
});
WARNING

If you use host permissions and target both MV2 and MV3, make sure to only include the required host permissions for each version:


export default defineConfig({
  manifest: ({ manifestVersion }) => ({
    host_permissions: manifestVersion === 2 ? [...] : [...],
  }),
});
Default Locale

export default defineConfig({
  manifest: {
    name: '__MSG_extName__',
    description: '__MSG_extDescription__',
    default_locale: 'en',
  },
});
See I18n docs for a full guide on internationalizing your extension.

Actions
In MV2, you have two options: browser_action and page_action. In MV3, they were merged into a single action API.

By default, whenever an action is generated, WXT falls back to browser_action when targeting MV2.

Action With Popup
To generate a manifest where a UI appears after clicking the icon, just create a Popup entrypoint.


export default defineConfig({
  hooks: {
    build: {
      manifestGenerated(manifest) {
        // Update the manifest variable by reference
        manifest.name = 'Overriden name';
      },
    },
  },
});
If you want to use a page_action for MV2, add the following meta tag to the HTML document's head:


<meta name="manifest.type" content="page_action" />
Action Without Popup
If you want to use the activeTab permission or the browser.action.onClicked event, but don't want to show a popup:

Delete the Popup entrypoint if it exists
Add the action key to your manifest:

export default defineConfig({
  manifest: {
    action: {},
  },
});
Same as an action with a popup, WXT will fallback on using browser_action for MV2. To use a page_action instead, add that key as well:


export default defineConfig({
  manifest: {
    action: {},
    page_action: {},
  },
});

Browser Startup
See the API Reference for a full list of config.

During development WXT uses web-ext by Mozilla to automatically open a browser window with your extension installed.

Config Files
You can configure browser startup in 3 places:

<rootDir>/web-ext.config.ts: Ignored from version control, this file lets you configure your own options for a specific project without affecting other developers


import { defineRunnerConfig } from 'wxt';

export default defineRunnerConfig({
  // ...
});
<rootDir>/wxt.config.ts: Via the runner config, included in version control

$HOME/web-ext.config.ts: Provide default values for all WXT projects on your computer

Recipes
Set Browser Binaries
To set or customize the browser opened during development:


export default defineRunnerConfig({
  binaries: {
    chrome: '/path/to/chrome-beta', // Use Chrome Beta instead of regular Chrome
    firefox: 'firefoxdeveloperedition', // Use Firefox Developer Edition instead of regular Firefox
    edge: '/path/to/edge', // Open MS Edge when running "wxt -b edge"
  },
});
Persist Data
By default, to keep from modifying your browser's existing profiles, web-ext creates a brand new profile every time you run the dev script.

Right now, Chromium based browsers are the only browsers that support overriding this behavior and persisting data when running the dev script multiple times.

To persist data, set the --user-data-dir flag:


Mac/Linux

Windows

export default defineRunnerConfig({
  chromiumArgs: ['--user-data-dir=./.wxt/chrome-data'],
});
Now, next time you run the dev script, a persistent profile will be created in .wxt/chrome-data/{profile-name}. With a persistent profile, you can install devtools extensions to help with development, allow the browser to remember logins, etc, without worrying about the profile being reset the next time you run the dev script.

TIP

You can use any directory you'd like for --user-data-dir, the examples above create a persistent profile for each WXT project. To create a profile for all WXT projects, you can put the chrome-data directory inside you're user's home directory.

Disable Opening Browser
If you prefer to load the extension into your browser manually, you can disable the auto-open behavior:


export default defineRunnerConfig({
  disabled: true,
});

Auto-imports
WXT uses unimport, the same tool as Nuxt, to setup auto-imports.


export default defineConfig({
  // See https://www.npmjs.com/package/unimport#configurations
  imports: {
    // ...
  },
});
By default, WXT automatically setups up auto-imports for all of it's own APIs:

browser from wxt/browser
defineContentScript from wxt/sandbox
defineBackground from wxt/sandbox
defineUnlistedScript from wxt/sandbox
createIntegratedUi from wxt/client
createShadowRootUi from wxt/client
createIframeUi from wxt/client
fakeBrowser from wxt/testing
And more!
WXT also adds some project directories as auto-import sources automatically:

<srcDir>/components/*
<srcDir>/composables/*
<srcDir>/hooks/*
<srcDir>/utils/*
All named and default exports from files in these directories are available everywhere else in your project without having to import them.

TypeScript
For TypeScript and your editor to recognize auto-imported variables, you need to run the wxt prepare command.

Add this command to your postinstall script so your editor has everything it needs to report type errors after installing dependencies:


// package.json
{
  "scripts": {
    "postinstall": "wxt prepare", 
  },
}
ESLint
ESLint doesn't know about the auto-imported variables unless they are explicitly defined in the ESLint's globals. By default, WXT will generate the config if it detects ESLint is installed in your project. If the config isn't generated automatically, you can manually tell WXT to generate it.


ESLint 9

ESLint 8

export default defineConfig({
  imports: {
    eslintrc: {
      enabled: 9,
    },
  },
});
Then in your ESLint config, import and use the generated file:


ESLint 9

ESLint 8

// eslint.config.mjs
import autoImports from './.wxt/eslint-auto-imports.mjs';

export default [
  autoImports,
  {
    // The rest of your config...
  },
];
Disabling Auto-imports
Not all developers like auto-imports. To disable them, set imports to false.


export default defineConfig({
  imports: false, 
});

Environment Variables
Dotenv Files
WXT supports dotenv files the same way as Vite. Create any of the following files:


.env
.env.local
.env.[mode]
.env.[mode].local
.env.[browser]
.env.[browser].local
.env.[mode].[browser]
.env.[mode].[browser].local
And any environment variables listed inside them will be available at runtime:


# .env
WXT_API_KEY=...

await fetch(`/some-api?apiKey=${import.meta.env.WXT_API_KEY}`);
Remember to prefix any environment variables with WXT_ or VITE_, otherwise they won't be available at runtime, as per Vite's convention.

Built-in Environment Variables
WXT provides some custom environment variables based on the current command:

Usage	Type	Description
import.meta.env.MANIFEST_VERSION	2 │ 3	The target manifest version
import.meta.env.BROWSER	string	The target browser
import.meta.env.CHROME	boolean	Equivalent to import.meta.env.BROWSER === "chrome"
import.meta.env.FIREFOX	boolean	Equivalent to import.meta.env.BROWSER === "firefox"
import.meta.env.SAFARI	boolean	Equivalent to import.meta.env.BROWSER === "safari"
import.meta.env.EDGE	boolean	Equivalent to import.meta.env.BROWSER === "edge"
import.meta.env.OPERA	boolean	Equivalent to import.meta.env.BROWSER === "opera"
You can also access all of Vite's environment variables:

Usage	Type	Description
import.meta.env.MODE	string	The mode the extension is running in
import.meta.env.PROD	boolean	When NODE_ENV='production'
import.meta.env.DEV	boolean	Opposite of import.meta.env.PROD
Manifest
To use environment variables in the manifest, you need to use the function syntax:


export default defineConfig({
  extensionApi: 'chrome',
  modules: ['@wxt-dev/module-vue'],
  manifest: { 
    oauth2: { 
      client_id: import.meta.env.WXT_APP_CLIENT_ID
    } 
  } 
  manifest: () => ({ 
    oauth2: { 
      client_id: import.meta.env.WXT_APP_CLIENT_ID
    } 
  }), 
});
WXT can't load your .env files until after the config file has been loaded. So by using the function syntax for manifest, it defers creating the object until after the .env files are loaded into the process.

Runtime Config
This API is still a WIP, with more features coming soon!

Define runtime configuration in a single place, <srcDir>/app.config.ts:


import { defineAppConfig } from 'wxt/sandbox';

// Define types for your config
declare module 'wxt/sandbox' {
  export interface WxtAppConfig {
    theme?: 'light' | 'dark';
  }
}

export default defineAppConfig({
  theme: 'dark',
});
WARNING

This file is committed to the repo, so don't put any secrets here. Instead, use Environment Variables

To access runtime config, WXT provides the useAppConfig function:


import { useAppConfig } from 'wxt/sandbox';

console.log(useAppConfig()); // { theme: "dark" }
Environment Variables in App Config
You can use environment variables in the app.config.ts file.


declare module 'wxt/sandbox' {
  export interface WxtAppConfig {
    apiKey?: string;
    skipWelcome: boolean;
  }
}

export default defineAppConfig({
  apiKey: import.meta.env.WXT_API_KEY,
  skipWelcome: import.meta.env.WXT_SKIP_WELCOME === 'true',
});
This has several advantages:

Define all expected environment variables in a single file
Convert strings to other types, like booleans or arrays
Provide default values if an environment variable is not provided

ite
WXT uses Vite under the hood to bundle your extension.

This page explains how to customize your project's Vite config. Refer to Vite's documentation to learn more about configuring the bundler.

TIP

In most cases, you shouldn't change Vite's build settings. WXT provides sensible defaults that output a valid extension accepted by all stores when publishing.

Change Vite Config
You can change Vite's config via the wxt.config.ts file:


// wxt.config.ts
import { defineConfig } from 'wxt';

export default defineConfig({
  vite: () => ({
    // Override config here, same as `defineConfig({ ... })`
    // inside vite.config.ts files
  }),
});
Add Vite Plugins
To add a plugin, install the NPM package and add it to the Vite config:


// wxt.config.ts
import { defineConfig } from 'wxt';
import VueRouter from 'unplugin-vue-router/vite';

export default defineConfig({
  vite: () => ({
    plugins: [
      VueRouter({
        /* ... */
      }),
    ],
  }),
});
WARNING

Due to the way WXT orchestrates Vite builds, some plugins may not work as expected. For example, vite-plugin-remove-console normally only runs when you build for production (vite build). However, WXT uses a combination of dev server and builds during development, so you need to manually tell it when to run:


// wxt.config.ts
import { defineConfig } from 'wxt';
import removeConsole from 'vite-plugin-remove-console';

export default defineConfig({
  vite: (configEnv) => ({
    plugins:
      configEnv.mode === 'production'
        ? [removeConsole({ includes: ['log'] })]
        : [],
  }),
});
Search GitHub issues if you run into issues with a specific plugin.

If an issue doesn't exist for your plugin, open a new one.

Build Modes
Because WXT is powered by Vite, it supports modes in the same way.

When running any dev or build commands, pass the --mode flag:


wxt --mode production
wxt build --mode development
wxt zip --mode testing
By default, --mode is development for the dev command and production for all other commands (build, zip, etc).

Get Mode at Runtime
You can access the current mode in your extension using import.meta.env.MODE:


switch (import.meta.env.MODE) {
  case 'development': // ...
  case 'production': // ...

  // Custom modes specified with --mode
  case 'testing': // ...
  case 'staging': // ...
  // ...
}

TypeScript Configuration
When you run wxt prepare, WXT generates a base TSConfig file for your project at <rootDir>/.wxt/tsconfig.json.

At a minimum, you need to create a TSConfig in your root directory that looks like this:


// <rootDir>/tsconfig.json
{
  "extends": ".wxt/tsconfig.json",
}
Or if you're in a monorepo, you may not want to extend the config. If you don't extend it, you need to add .wxt/wxt.d.ts to the TypeScript project:


/// <reference types="./.wxt/wxt.d.ts" />
Compiler Options
To specify custom compiler options, add them in <rootDir>/tsconfig.json:


// <rootDir>/tsconfig.json
{
  "extends": ".wxt/tsconfig.json",
  "compilerOptions": {
    "jsx": "preserve",
  },
}
TSConfig Paths
WXT provides a default set of path aliases.

Alias	To	Example
~~	<rootDir>/*	import "~~/scripts"
@@	<rootDir>/*	import "@@/scripts"
~	<srcDir>/*	import { toLowerCase } from "~/utils/strings"
@	<srcDir>/*	import { toLowerCase } from "@/utils/strings"
To add your own, DO NOT add them to your tsconfig.json! Instead, use the alias option in wxt.config.ts.

This will add your custom aliases to <rootDir>/.wxt/tsconfig.json next time you run wxt prepare. It also adds your alias to the bundler so it can resolve imports.


import { resolve } from 'node:path';

export default defineConfig({
  alias: {
    // Directory:
    testing: resolve('utils/testing'),
    // File:
    strings: resolve('utils/strings.ts'),
  },
});

import { fakeTab } from 'testing/fake-objects';
import { toLowerCase } from 'strings';

Hooks
WXT includes a system that lets you hook into the build process and make changes.

Adding Hooks
The easiest way to add a hook is via the wxt.config.ts. Here's an example hook that modifies the manifest.json file before it is written to the output directory:


// wxt.config.ts
export default defineConfig({
  hooks: {
    'build:manifestGenerated': (wxt, manifest) => {
      if (wxt.config.mode === 'development') {
        manifest.title += ' (DEV)';
      }
    },
  },
});
Most hooks provide the wxt object as the first argument. It contains the resolved config and other info about the current build. The other arguments can be modified by reference to change different parts of the build system.

Putting one-off hooks like this in your config file is simple, but if you find yourself writing lots of hooks, you should extract them into WXT Modules instead.

Execution Order
Because hooks can be defined in multiple places, including WXT Modules, the order which they're executed can matter. Hooks are executed in the following order:

NPM modules in the order listed in the modules config
User modules in /modules folder, loaded alphabetically
Hooks listed in your wxt.config.ts
To see the order for your project, run wxt prepare --debug flag and search for the "Hook execution order":


⚙ Hook execution order:
⚙   1. wxt:built-in:unimport
⚙   2. src/modules/auto-icons.ts
⚙   3. src/modules/example.ts
⚙   4. src/modules/i18n.ts
⚙   5. wxt.config.ts > hooks
Changing execution order is simple:

Prefix your user modules with a number (lower numbers are loaded first):

📁 modules/
   📄 0.my-module.ts
   📄 1.another-module.ts
If you need to run an NPM module after user modules, just make it a user module and prefix the filename with a number!

// modules/2.i18n.ts
export { default } from '@wxt-dev/i18n/module';

Entrypoint Loaders
To generate the manifest and other files at build-time, WXT must import each entrypoint to get their options, like content script matches. For HTML files, this is easy. For JS/TS entrypoints, the process is more complicated.

When loading your JS/TS entrypoints, they are imported into a NodeJS environment, not the browser environment that they normally run in. This can lead to issues commonly seen when running browser-only code in a NodeJS environment, like missing global variables.

WXT does several pre-processing steps to try and prevent errors during this process:

Use linkedom to make a small set of browser globals (window, document, etc) available.
Use @webext-core/fake-browser to create a fake version of the chrome and browser globals expected by extensions.
Pre-process the JS/TS code, stripping out the main function then tree-shaking unused code from the file
However, this process is not perfect. It doesn't setup all the globals found in the browser and the APIs may behave differently. As such, you should avoid using browser or extension APIs outside the main function of your entrypoints!

TIP

If you're running into errors while importing entrypoints, run wxt prepare --debug to see more details about this process. When debugging, WXT will print out the pre-processed code to help you identify issues.

Once the environment has been polyfilled and your code pre-processed, it's up the entrypoint loader to import your code, extracting the options from the default export.

There are two options for loading your entrypoints:

vite-node - default as of v0.19.0
jiti (DEPRECATED, will be removed in v0.20.0) - Default before v0.19.0
vite-node
Since 0.19.0, WXT uses vite-node, the same tool that powers Vitest and Nuxt, to import your entrypoint files. It re-uses the same vite config used when building your extension, making it the most stable entrypoint loader.

jiti
To enable jiti:


export default defineConfig({
  entrypointLoader: 'jiti',
});
This is the original method WXT used to import TS files. However, because it doesn't support vite plugins like vite-node, it does one additional pre-processing step: It removes ALL imports from your code.

That means you cannot use imported variables outside the main function in JS entrypoints, like for content script matches or other options:


// entrypoints/content.ts
import { GOOGLE_MATCHES } from '~/utils/match-patterns';

export default defineContentScript({
  matches: GOOGLE_MATCHES,
  main() {
    // ...
  },
});

$ wxt build
wxt build

WXT 0.14.1
ℹ Building chrome-mv3 for production with Vite 5.0.5
✖ Command failed after 360 ms

[8:55:54 AM]  ERROR  entrypoints/content.ts: Cannot use imported variable "GOOGLE_MATCHES" before main function.
Usually, this error occurs when you try to extract options into a shared file or when running code outside the main function. To fix the example from above, use literal values when defining an entrypoint instead of importing them:


import { GOOGLE_MATCHES } from '~/utils/match-patterns'; 

export default defineContentScript({
  matches: GOOGLE_MATCHES, 
  matches: ['*//*.google.com/*'], 
  main() {
    // ...
  },
});


Extension APIs
Chrome Docs • Firefox Docs

Different browsers provide different global variables for accessing the extension APIs (chrome provides chrome, firefox provides browser, etc).

WXT simplifies this - always use browser:


browser.action.onClicked.addListener(() => {
  // ...
});
Other than that, refer to Chrome and Mozilla's documentation for how to use specific APIs. Everything a normal extension can do, WXT can do as well, just via browser instead of chrome.

Webextension Polyfill
Since v0.1.0

By default, WXT uses the webextension-polyfill by Mozilla to make the extension API consistent between browsers.

To access types, you should import the relevant namespace from wxt/browser:


import { Runtime } from 'wxt/browser';

function handleMessage(message: any, sender: Runtime.Sender) {
  // ...
}
Disabling the polyfill
Since v0.19.0

After the release of MV3 and Chrome's official deprecation of MV2 in June 2024, the polyfill isn't really doing anything useful anymore.

You can disable it with a single line:


// wxt.config.ts
export default defineConfig({
  extensionApi: 'chrome',
});
This will change wxt/browser to simply export the browser or chrome globals based on browser at runtime:


export const browser: WxtBrowser =
  // @ts-expect-error
  globalThis.browser?.runtime?.id == null
    ? globalThis.chrome
    : // @ts-expect-error
      globalThis.browser;
Accessing types is a little different with the polyfill disabled. They do not need to be imported; they're available on the browser object itself:


function handleMessage(message: any, sender: browser.runtime.Sender) {
  // ...
}
Feature Detection
Depending on the manifest version and browser, some APIs are not available at runtime. If an API is not available, it will be undefined.

WARNING

Types will not help you here. The types WXT provides for browser assume all APIs exist. You are responsible for knowing whether an API is available or not.

To check if an API is available, use feature detection:


if (browser.runtime.onSuspend != null) {
  browser.runtime.onSuspend.addListener(() => {
    // ...
  });
}
Here, optional chaining is your best friend:


browser.runtime.onSuspend?.addListener(() => {
  // ...
});
Alternatively, if you're trying to use similar APIs under different names (to support MV2 and MV3), you can do something like this:


(browser.action ?? browser.browser_action).onClicked.addListener(() => {
  //
});

Assets
/assets Directory
Any assets imported or referenced inside the <srcDir>/assets/ directory will be processed by WXT's bundler.

Here's how you access them:


JS

HTML

CSS

import imageUrl from '~/assets/image.png';

const img = document.createElement('img');
img.src = imageUrl;
/public Directory
Files inside <srcDir>/public/ are copied into the output folder as-is, without being processed by WXT's bundler.

Here's how you access them:


JS

HTML

CSS

import imageUrl from '/image.png';

const img = document.createElement('img');
img.src = imageUrl;
Inside Content Scripts
Assets inside content scripts are a little different. By default, when you import an asset, it returns just the path to the asset. This is because Vite assumes you're loading assets from the same hostname.

But, inside content scripts, the hostname is whatever the tab is set to. So if you try to fetch the asset, manually or as an <img>'s src, it will be loaded from the tab's website, not your extension.

To fix this, you need to convert the image to a full URL using browser.runtime.getURL:


// entrypoints/content.ts
import iconUrl from '/icon/128.png';

export default defineContentScript({
  matches: ['*://*.google.com/*'],
  main() {
    console.log(iconUrl); // "/icon/128.png"
    console.log(browser.runtime.getURL(iconUrl)); // "chrome-extension://<id>/icon/128.png"
  },
});

argeting Different Browsers
When building an extension with WXT, you can create multiple builds of your extension targeting different browsers and manifest versions.

Target a Browser
Use the -b CLI flag to create a separate build of your extension for a specific browser. By default, chrome is targeted.


wxt            # same as: wxt -b chrome
wxt -b firefox
wxt -b custom
During development, if you target Firefox, Firefox will open. All other strings open Chrome by default. To customize which browsers open, see Set Browser Binaries.

Additionally, WXT defines several constants you can use at runtime to detect which browser is in use:


if (import.meta.env.BROWSER === 'firefox') {
  console.log('Do something only in Firefox builds');
}
if (import.meta.env.FIREFOX) {
  // Shorthand, equivalent to the if-statement above
}
Read about Built-in Environment Variables for more details.

Target a Manifest Version
To target specific manifest versions, use the --mv2 or --mv3 CLI flags.

Default Manifest Version

By default, WXT will target MV2 for Safari and Firefox and MV3 for all other browsers.

Similar to the browser, you can get the target manifest version at runtime using the built-in environment variable:


if (import.meta.env.MANIFEST_VERSION === 2) {
  console.log('Do something only in MV2 builds');
}
Filtering Entrypoints
Every entrypoint can be included or excluded when targeting specific browsers via the include and exclude options.

Here are some examples:

Content script only built when targeting firefox:


export default defineContentScript({
  include: ['firefox'],

  main(ctx) {
    // ...
  },
});
HTML file only built for all targets other than chrome:


<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="manifest.exclude" content="['chrome', ...]" />
  </head>
  <body>
    <!-- ... -->
  </body>
</html>

Content Scripts
Context
The first argument to a content script's main function is it's "context".


// entrypoints/content.ts
export default defineContentScript({
  main(ctx) {},
});
This object is responsible for tracking whether or not the content script's context is "invalidated". Most browsers, by default, do not stop content scripts if the extension is uninstalled, updated, or disabled. When this happens, content scripts start reporting this error:


Error: Extension context invalidated.
The ctx object provides several helpers to stop asynchronous code from running once the context is invalidated:


ctx.addEventListener(...);
ctx.setTimeout(...);
ctx.setInterval(...);
ctx.requestAnimationFrame(...);
// and more
You can also check if the context is invalidated manually:


if (ctx.isValid) {
  // do something
}
// OR
if (ctx.isInvalid) {
  // do something
}
CSS
In regular web extensions, CSS for content scripts is usually a separate CSS file, that is added to a CSS array in the manifest:


{
  "content_scripts": [
    {
      "css": ["content/style.css"],
      "js": ["content/index.js"],
      "matches": ["*://*/*"]
    }
  ]
}
In WXT, to add CSS to a content script, simply import the CSS file into your JS entrypoint, and WXT will automatically add the bundled CSS output to the css array.


// entrypoints/content/index.ts
import './style.css';

export default defineContentScript({
  // ...
});
To create a standalone content script that only includes a CSS file:

Create the CSS file: entrypoints/example.content.css
Use the build:manifestGenerated hook to add the content script to the manifest:

// wxt.config.ts
export default defineConfig({
  hooks: {
    "build:manifestGenerated": (wxt, manifest) => {
      manifest.content_scripts ??= [];
      manifest.content_scripts.push({
        // Build extension once to see where your CSS get's written to
        css: ["content-scripts/example.css"],
        matches: ["*://*/*"]
      )
    }
  }
})
UI
WXT provides 3 built-in utilities for adding UIs to a page from a content script:

Integrated - createIntegratedUi
Shadow Root -createShadowRootUi
IFrame - createIframeUi
Each has their own set of advantages and disadvantages.

Method	Isolated Styles	Isolated Events	HMR	Use page's context
Integrated	❌	❌	❌	✅
Shadow Root	✅	✅ (off by default)	❌	✅
IFrame	✅	✅	✅	❌
Integrated
Integrated content script UIs are injected alongside the content of a page. This means that they are affected by CSS on that page.


Vanilla

Vue

React

Svelte

Solid

// entrypoints/example-ui.content.ts
export default defineContentScript({
  matches: ['<all_urls>'],

  main(ctx) {
    const ui = createIntegratedUi(ctx, {
      position: 'inline',
      anchor: 'body',
      onMount: (container) => {
        // Append children to the container
        const app = document.createElement('p');
        app.textContent = '...';
        container.append(app);
      },
    });

    // Call mount to add the UI to the DOM
    ui.mount();
  },
});
See the API Reference for the complete list of options.

Shadow Root
Often in web extensions, you don't want your content script's CSS affecting the page, or vise-versa. The ShadowRoot API is ideal for this.

WXT's createShadowRootUi abstracts all the ShadowRoot setup away, making it easy to create UIs whose styles are isolated from the page. It also supports an optional isolateEvents parameter to further isolate user interactions.

To use createShadowRootUi, follow these steps:

Import your CSS file at the top of your content script
Set cssInjectionMode: "ui" inside defineContentScript
Define your UI with createShadowRootUi()
Mount the UI so it is visible to users

Vanilla

Vue

React

Svelte

Solid

// 1. Import the style
import './style.css';

export default defineContentScript({
  matches: ['<all_urls>'],
  // 2. Set cssInjectionMode
  cssInjectionMode: 'ui',

  async main(ctx) {
    // 3. Define your UI
    const ui = await createShadowRootUi(ctx, {
      name: 'example-ui',
      position: 'inline',
      anchor: 'body',
      onMount(container) {
        // Define how your UI will be mounted inside the container
        const app = document.createElement('p');
        app.textContent = 'Hello world!';
        container.append(app);
      },
    });

    // 4. Mount the UI
    ui.mount();
  },
});
See the API Reference for the complete list of options.

Full examples:

react-content-script-ui
tailwindcss
IFrame
If you don't need to run your UI in the same frame as the content script, you can use an IFrame to host your UI instead. Since an IFrame just hosts an HTML page, HMR is supported.

WXT provides a helper function, createIframeUi, which simplifies setting up the IFrame.

Create an HTML page that will be loaded into your IFrame:


<!-- entrypoints/example-iframe.html -->
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Your Content Script IFrame</title>
  </head>
  <body>
    <!-- ... -->
  </body>
</html>
Add the page to the manifest's web_accessible_resources:


// wxt.config.ts
export default defineConfig({
  manifest: {
    web_accessible_resources: [
      {
        resources: ['example-iframe.html'],
        matches: [...],
      },
    ],
  },
});
Create and mount the IFrame:


export default defineContentScript({
  matches: ['<all_urls>'],

  main(ctx) {
    // Define the UI
    const ui = createIframeUi(ctx, {
      page: '/example-iframe.html',
      position: 'inline',
      anchor: 'body',
      onMount: (wrapper, iframe) => {
        // Add styles to the iframe like width
        iframe.width = '123';
      },
    });

    // Show UI to user
    ui.mount();
  },
});
See the API Reference for the complete list of options.

Isolated World vs Main World
By default, all content scripts run in an isolated context where only the DOM is shared with the webpage it is running on - an "isolated world". In MV3, Chromium introduced the ability to run content scripts in the "main" world - where everything, not just the DOM, is available to the content script, just like if the script were loaded by the webpage.

You can enable this for a content script by setting the world option:


export default defineContentScript({
  world: 'MAIN',
});
However, this approach has several notable drawbacks:

Doesn't support MV2
world: "MAIN" is only supported by Chromium browsers
Main world content scripts don't have access to the extension API
Instead, WXT recommends injecting a script into the main world manually using it's injectScript function. This will address the drawbacks mentioned before.

injectScript supports both MV2 and MV3
injectScript supports all browsers
Having a "parent" content script means you can send messages back and forth, making it possible to access the extension API
To use injectScript, we need two entrypoints, one content script and one unlisted script:


📂 entrypoints/
   📄 example.content.ts
   📄 example-main-world.ts

// entrypoints/example-main-world.ts
export default defineUnlistedScript(() => {
  console.log('Hello from the main world!');
});

// entrypoints/example.content.ts
export default defineContentScript(async () => {
  await injectScript('/example-main-world.js', {
    keepInDom: true,
  });
});
injectScript works by creating a script element on the page pointing to your script. This loads the script into the page's context so it runs in the main world.

injectScript returns a promise, that when resolved, means the script has been evaluated by the browser and you can start communicating with it.

Warning: run_at Caveat

For MV3, injectScript is synchronous and the injected script will be evaluated at the same time as your the content script's run_at.

However for MV2, injectScript has to fetch the script's text content and create an inline <script> block. This means for MV2, your script is injected asynchronously and it will not be evaluated at the same time as your content script's run_at.

Dealing with SPAs
It is difficult to write content scripts for SPAs (single page applications) and websites using HTML5 history mode for navigation because content scripts are only ran on full page reloads. SPAs and websites that take advantage of HTML5 history mode do not perform a full reload when changing paths, and thus your content script isn't going to be ran when you expect it to be.

Let's look at an example. Say you want to add a UI to YouTube when watching a video:


export default defineContentScript({
  matches: ['*://*.youtube.com/watch*'],
  main(ctx) {
    console.log('YouTube content script loaded');

    mountUi(ctx);
  },
});

function mountUi(ctx: ContentScriptContext): void {
  // ...
}
You're only going to see "YouTube content script loaded" when reloading the watch page or when navigating directly to it from another website.

To get around this, you'll need to manually listen for the path to change and run your content script when the URL matches what you expect it to match.


const watchPattern = new MatchPattern('*://*.youtube.com/watch*');

export default defineContentScript({
  matches: ['*://*.youtube.com/*'],
  main(ctx) {
    ctx.addEventListener(window, 'wxt:locationchange', ({ newUrl }) => {
      if (watchPattern.includes(newUrl)) mainWatch(ctx);
    });
  },
});

function mainWatch(ctx: ContentScriptContext) {
  mountUi(ctx);
}

Storage
Chrome Docs • Firefox Docs

You can use the vanilla APIs (see docs above), use WXT's built-in storage API, or install a package from NPM.

Alternatives
wxt/storage (recommended): WXT ships with its own wrapper around the vanilla storage APIs that simplifies common use cases

DIY: If you're migrating to WXT and already have a storage wrapper, keep using it. In the future, if you want to delete that code, you can use one of these alternatives, but there's no reason to replace working code during a migration.

Any other NPM package: There are lots of wrappers around the storage API, you can find one you like. Here's some popular ones:

webext-storage - A more usable typed storage API for Web Extensions
@webext-core/storage - A type-safe, localStorage-esque wrapper around the web extension storage APIs


Messaging
Chrome Docs • Firefox Docs

Read the docs linked above to learn more about using the vanilla messaging APIs.

Alternatives
The vanilla APIs are difficult to use and are a pain point to many new extension developers. For this reason, WXT recommends installing an NPM package that wraps around the vanilla APIs.

Here are some popular messaging libraries that support all browsers and work with WXT:

trpc-chrome - tRPC adapter for Web Extensions.
webext-bridge - Messaging in WebExtensions made super easy. Out of the box.
@webext-core/messaging - Light weight, type-safe wrapper around the web extension messaging APIs
@webext-core/proxy-service - A type-safe wrapper around the web extension messaging APIs that lets you call a function from anywhere, but execute it in the background.

I18n
Chrome Docs • Firefox Docs

This page discusses how to setup internationalization using the vanilla browser.i18n APIs and mentions some alternatives if you want to use something else.

Usage
Alternatives
Usage
Add default_locale to your manifest:


export default defineConfig({
  manifest: {
    default_locale: 'en',
  },
});
Create messages.json files in the public/ directory:


📂 {srcDir}/
   📂 public/
      📂 _locales/
         📂 en/
            📄 messages.json
         📂 de/
            📄 messages.json
         📂 ko/
            📄 messages.json

// public/_locales/en/messages.json
{
  "helloWorld": {
    "message": "Hello world!",
  },
}
Get the translation:


browser.i18n.getMessage('helloWorld');
Optional: Add translations for extension name and description:


{
  "extName": {
    "message": "..."
  },
  "extDescription": {
    "message": "..."
  },
  "helloWorld": {
    "message": "Hello world!"
  }
}

export default defineConfig({
  manifest: {
    name: '__MSG_extName__',
    description: '__MSG_extDescription__',
    default_locale: 'en',
  },
});
Alternatives
The vanilla API has very few features, which is why you may want to consider using third-party NPM packages like i18next, react-i18n, vue-i18n, etc.

However, it is recommended you stick with the vanilla API (or a package based on top of the vanilla API, like @wxt-dev/i18n), because:

They can localize text in your manifest and CSS files
Translations are loaded synchronously
Translations are not bundled multiple times, keeping your extension small
Zero configuration
Here are some examples of how to setup a third party i18n library:

vue-i18n

Scripting
Chrome Docs • Firefox Docs

Refer to the browser docs above for basics on how the API works.

Execute Script Return Values
When using browser.scripting.executeScript, you can execute content scripts or unlisted scripts. To return a value, just return a value from the script's main function.


// entrypoints/background.ts
const res = await browser.scripting.executeScript({
  target: { tabId },
  files: ['content-scripts/example.js'],
});
console.log(res); // "Hello John!"

// entrypoints/example.content.ts
export default defineContentScript({
  registration: 'runtime',
  main(ctx) {
    console.log('Script was executed!');
    return 'Hello John!';
  },
});

WXT Modules
WXT provides a "module system" that let's you run code at different steps in the build process to modify it.

Adding a Module
Module Options
Execution Order
Writing Modules
Recipes
Example Modules
Adding a Module
There are two ways to add a module to your project:

NPM: install an NPM package, like @wxt-dev/auto-icons and add it to your config:

// wxt.config.ts
export default defineConfig({
  modules: ['@wxt-dev/auto-icons'],
});
Searching for "wxt module" on NPM is a good way to find published WXT modules.

Local: add a file to your project's modules/ directory:

<srcDir>/
  modules/
    my-module.ts
To learn more about writing your own modules, read the Writing Modules docs.

Module Options
WXT modules may require or allow setting custom options to change their behavior. There are two types of options:

Build-time: Any config used during the build process, like feature flags
Runtime: Any config accessed at runtime, like callback functions
Build-time options are placed in your wxt.config.ts, while runtime options is placed in the app.config.ts file. Refer to each module's documentation about what options are required and where they should be placed.

If you use TypeScript, modules augment WXT's types so you will get type errors if options are missing or incorrect.

Execution Order
Modules are loaded in the same order as hooks are executed. Refer to the Hooks documentation for more details.

Writing Modules
Here's what a basic WXT module looks like:


import { defineWxtModule } from 'wxt/modules';

export default defineWxtModule({
  setup(wxt) {
    // Your module code here...
  },
});
Each module's setup function is executed after the wxt.config.ts file is loaded. The wxt object provides everything you need to write a module:

Use wxt.hook(...) to hook into the build's lifecycle and make changes
Use wxt.config to get the resolved config from the project's wxt.config.ts file
Use wxt.logger to log messages to the console
and more!
Refer to the API reference for a complete list of properties and functions available.

Also to make sure and read about all the hooks that are available - they are essential to writing modules.

Recipes
Modules are complex and require a deeper understanding of WXT's code and how it works. The best way to learn is by example.

Update resolved config

import { defineWxtModule } from 'wxt/modules';

export default defineWxtModule({
  setup(wxt) {
    wxt.hook('config:resolved', () => {
      wxt.config.outDir = 'dist';
    });
  },
});
Add built-time config

import { defineWxtModule } from 'wxt/modules';
import 'wxt';

export interface MyModuleOptions {
  // Add your build-time options here...
}
declare module 'wxt' {
  export interface InlineConfig {
    // Add types for the "myModule" key in wxt.config.ts
    myModule: MyModuleOptions;
  }
}

export default defineWxtModule<AnalyticModuleOptions>({
  configKey: 'myModule',

  // Build time config is available via the second argument of setup
  setup(wxt, options) {
    console.log(options);
  },
});
Add runtime config

import { defineWxtModule } from 'wxt/modules';
import 'wxt/sandbox';

export interface MyModuleRuntimeOptions {
  // Add your runtime options here...
}
declare module 'wxt/sandbox' {
  export interface WxtAppConfig {
    myModule: MyModuleOptions;
  }
}
Runtime options are returned when calling


const config = useAppConfig();
console.log(config.myModule);
This is very useful when generating runtime code.

Generate output file

import { defineWxtModule } from 'wxt/modules';

export default defineWxtModule({
  setup(wxt) {
    // Relative to the output directory
    const generatedFilePath = 'some-file.txt';

    wxt.hook('build:publicAssets', (_, assets) => {
      assets.push({
        relativeDest: generatedFilePath,
        contents: 'some generated text',
      });
    });

    wxt.hook('build:manifestGenerated', (_, manifest) => {
      manifest.web_accessible_resources ??= [];
      manifest.web_accessible_resources.push({
        matches: ['*://*'],
        resources: [generatedFilePath],
      });
    });
  },
});
This file could then be loaded at runtime:


const res = await fetch(browser.runtime.getURL('/some-text.txt'));
Generate runtime module
Create a file in .wxt, add an alias to import it, and add auto-imports for exported variables.


import { defineWxtModule } from 'wxt/modules';
import { resolve } from 'node:path';

export default defineWxtModule({
  imports: [
    // Add auto-imports
    { from: '#analytics', name: 'analytics' },
    { from: '#analytics', name: 'reportEvent' },
    { from: '#analytics', name: 'reportPageView' },
  ],

  setup(wxt) {
    const analyticsModulePath = resolve(
      wxt.config.wxtDir,
      'analytics/index.ts',
    );
    const analyticsModuleCode = `
      import { createAnalytics } from 'some-module';

      export const analytics = createAnalytics(useAppConfig().analytics);
      export const { reportEvent, reportPageView } = analytics;
    `;

    addAlias(wxt, '#analytics', analyticsModulePath);

    wxt.hook('prepare:types', async (_, entries) => {
      entries.push({
        path: analyticsModulePath,
        text: analyticsModuleCode,
      });
    });
  },
});
Generate declaration file

import { defineWxtModule } from 'wxt/modules';
import { resolve } from 'node:path';

export default defineWxtModule({
  setup(wxt) {
    const typesPath = resolve(wxt.config.wxtDir, 'my-module/types.d.ts');
    const typesCode = `
      // Declare global types, perform type augmentation
    `;

    wxt.hook('prepare:types', async (_, entries) => {
      entries.push({
        path: 'my-module/types.d.ts',
        text: `
          // Declare global types, perform type augmentation, etc
        `,
        // IMPORTANT - without this line your declaration file will not be a part of the TS project:
        tsReference: true,
      });
    });
  },
});
Example Modules
You should also look through the code of modules other people have written and published. Here's some examples:

@wxt-dev/auto-icons
@wxt-dev/i18n
@wxt-dev/module-vue
@wxt-dev/module-solid
@wxt-dev/module-react
@wxt-dev/module-svelte


Frontend Frameworks
Built-in Modules
WXT has preconfigured modules for the most popular frontend frameworks:

@wxt-dev/module-react
@wxt-dev/module-vue
@wxt-dev/module-svelte
@wxt-dev/module-solid
Install the module for your framework, then add it to your config:


React

Vue

Svelte

Solid

import { defineConfig } from 'wxt';

export default defineConfig({
  modules: ['@wxt-dev/module-react'],
});
Adding Vite Plugins
If your framework doesn't have an official WXT module, no worries! WXT supports any framework with a Vite plugin.

Just add the Vite plugin to your config and you're good to go! Use the framework in HTML pages or content scripts and it will just work 👍


import { defineConfig } from 'wxt';
import react from '@vitejs/plugin-react';

export default defineConfig({
  vite: () => ({
    plugins: [react()],
  }),
});
The WXT modules just simplify the configuration and add auto-imports. They're not much different than the above.

Multiple Apps
Since web extensions usually contain multiple UIs across multiple entrypoints (popup, options, changelog, side panel, content scripts, etc), you'll need to create individual app instances, one per entrypoint.

Usually, this means each entrypoint should be a directory with it's own files inside it. Here's the recommended folder structure:


📂 {srcDir}/
   📂 assets/          <---------- Put shared assets here
      📄 tailwind.css
   📂 components/
      📄 Button.tsx
   📂 entrypoints/
      📂 options/       <--------- Use a folder with an index.html file in it
         📁 pages/      <--------- A good place to put your router pages if you have them
         📄 index.html
         📄 App.tsx
         📄 main.tsx    <--------- Create and mount your app here
         📄 style.css   <--------- Entrypoint-specific styles
         📄 router.ts
Configuring Routers
All frameworks come with routers for building a multi-page app using the URL's path... But web extensions don't work like this. Since HTML files are static, chrome-extension://{id}/popup.html, there's no way to change the entire path for routing.

Instead, you need to configure the router to run in "hash" mode, where the routing information is a part of the URL's hash, not the path (ie: popup.html#/ and popup.html#/account/settings).

Refer to your router's docs for information about hash mode and how to enable it. Here's a non-extensive list of a few popular routers:

react-router
vue-router
svelte-spa-router
solid-router
Edit this page
Last updated: 10/18/24, 7:28 AM

ES Modules
Currently, ESM entrypoints are opt-in, so you must configure each entrypoint with that in mind.

HTML Pages ≥0.0.1
In general, you should always make HTML pages import ESM scripts, unless you need to support old browsers.

To make a script ESM, add type="module":


<script src="./main.ts"></script> 
<script src="./main.ts" type="module"></script> 
Background ≥0.16.0
In your background script, set type: "module":


export default defineBackground({
  type: 'module', // !code ++
  main() {
    // ...
  },
});
WARNING

Only MV3 supports ESM background scripts/service workers. When targeting MV2, the type option is ignored and the background is always bundled into a single file as IIFE.

Content Scripts
WXT does not yet include built-in support for ESM content scripts. The plan is to add support for chunking to reduce bundle size, but not support HMR for now. There are several technical issues that make implementing a generic solution for HMR impossible. See Content Script ESM Support #357 for details.

If you can't wait, and need ESM support right now, you can implement ESM support manually. See the ESM Content Script UI example to get started.

Edit this page
Last updated: 10/18/24, 7:28 AM

Remote Code
WXT will automatically download and bundle imports with the url: prefix so the extension does not depend on remote code, a requirement from Google for MV3.

Google Analytics
For example, you can import Google Analytics:


// utils/google-analytics.ts
import 'url:https://www.googletagmanager.com/gtag/js?id=G-XXXXXX';

window.dataLayer = window.dataLayer || [];
// NOTE: This line is different from Google's documentation
window.gtag = function () {
  dataLayer.push(arguments);
};
gtag('js', new Date());
gtag('config', 'G-XXXXXX');
Then you can import this in your HTML files to enable Google Analytics:


// popup/main.ts
import '~/utils/google-analytics';

gtag('event', 'event_name', {
  key: 'value',
});
Edit this page
Last updated: 10/18/24, 7:28 AM

Unit Testing
Vitest
Example Tests
Other Testing Frameworks
Vitest
WXT provides first class support for Vitest for unit testing:


// vitest.config.ts
import { defineConfig } from 'vitest/config';
import { WxtVitest } from 'wxt/testing';

export default defineConfig({
  plugins: [WxtVitest()],
});
This plugin does several things:

Polyfills the extension API, browser, with an in-memory implementation using @webext-core/fake-browser
Adds all vite config or plugins in wxt.config.ts
Configures auto-imports (if enabled)
Applies internal WXT vite plugins for things like bundling remote code
Sets up global variables provided by WXT (import.meta.env.BROWSER, import.meta.env.MANIFEST_VERSION, import.meta.env.IS_CHROME, etc)
Configures aliases (@/*, @@/*, etc) so imports can be resolved
Here are real projects with unit testing setup. Look at the code and tests to see how they're written.

aklinker1/github-better-line-counts
wxt-dev/examples's Vitest Example
Example Tests
This example demonstrates that you don't have to mock browser.storage (used by wxt/storage) in tests - @webext-core/fake-browser implements storage in-memory so it behaves like it would in a real extension!


import { describe, it, expect } from 'vitest';
import { fakeBrowser } from 'wxt/testing';

const accountStorage = storage.defineItem<Account>('local:account');

async function isLoggedIn(): Promise<Account> {
  const value = await accountStorage.getValue();
  return value != null;
}

describe('isLoggedIn', () => {
  beforeEach(() => {
    // See https://webext-core.aklinker1.io/fake-browser/reseting-state
    fakeBrowser.reset();
  });

  it('should return true when the account exists in storage', async () => {
    const account: Account = {
      username: '...',
      preferences: {
        // ...
      },
    };
    await accountStorage.setValue(account);

    expect(await isLoggedIn()).toBe(true);
  });

  it('should return false when the account does not exist in storage', async () => {
    await accountStorage.deleteValue();

    expect(await isLoggedIn()).toBe(false);
  });
});
Other Testing Frameworks
To use a different framework, you will likely have to disable auto-imports, setup import aliases, manually mock the extension APIs, and setup the test environment to support all of WXT's features that you use.

It is possible to do, but will require a bit more setup. Refer to Vitest's setup for an example of how to setup a test environment:

https://github.com/wxt-dev/wxt/blob/main/packages/wxt/src/testing/wxt-vitest-plugin.ts

Edit this page
Last updated: 10/18/24, 7:28 AM

E2E Testing
Playwright
Playwright is the only good option for writing Chrome Extension end-to-end tests.

To add E2E tests to your project, follow Playwright's Chrome Extension docs. When you have to pass the path to your extension, pass the output directory, /path/to/project/.output/chrome-mv3.

For a complete example, see the WXT's Playwright Example.

Edit this page
Last updated: 10/18/24, 7:28 AM

Publishing
WXT can ZIP your extension and submit it to various stores for review or for self-hosting.

First Time Publishing
If you're publishing an extension to a store for the first time, you must manually navigate the process. WXT doesn't help you create listings, each store has unique steps and requirements that you need to familiarize yourself with.

For specific details about each store, see the stores sections below.

Chrome Web Store
Firefox Addon Store
Edge Addons
Automation
WXT provides two commands to help automate submitting a new version for review and publishing:

wxt submit init: Setup all the required secrets and options for the wxt submit command
wxt submit: Submit new versions of your extension for review (and publish them automatically once approved)
To get started, run wxt submit init and follow the prompts. Once finished, you should have a .env.submit file! WXT will use this file to submit your updates.

In CI, make sure you add all the environment variables to the submit step.

To submit a new version for publishing, build all the ZIPs you plan on releasing:


wxt zip
wxt zip -b firefox
Then run the wxt submit command, passing in all the ZIP files you want to release. In this case, we'll do a release for all 3 major stores: Chrome Web Store, Edge Addons, and Firefox Addons Store.

If it's your first time running the command or you recently made changes to the release process, you'll want to test your secrets by passing the --dry-run flag.


wxt submit --dry-run \
  --chrome-zip .output/{your-extension}-{version}-chrome.zip \
  --firefox-zip .output/{your-extension}-{version}-firefox.zip --firefox-sources-zip .output/{your-extension}-{version}-sources.zip \
  --edge-zip .output/{your-extension}-{version}-chrome.zip
If the dry run passes, remove the flag and do the actual release:


wxt submit \
  --chrome-zip .output/{your-extension}-{version}-chrome.zip \
  --firefox-zip .output/{your-extension}-{version}-firefox.zip --firefox-sources-zip .output/{your-extension}-{version}-sources.zip \
  --edge-zip .output/{your-extension}-{version}-chrome.zip
WARNING

See the Firefox Addon Store section for more details about the --firefox-sources-zip option.

GitHub Action
Here's an example of a GitHub Action that submits new versions of an extension for review. Ensure that you've added all required secrets used in the workflow to the repo's settings.


name: Release

on:
  workflow_dispatch:

jobs:
  submit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install

      - name: Zip extensions
        run: |
          pnpm zip
          pnpm zip:firefox

      - name: Submit to stores
        run: |
          pnpm wxt submit \
            --chrome-zip .output/*-chrome.zip \
            --firefox-zip .output/*-firefox.zip --firefox-sources-zip .output/*-sources.zip
        env:
          CHROME_EXTENSION_ID: ${{ secrets.CHROME_EXTENSION_ID }}
          CHROME_CLIENT_ID: ${{ secrets.CHROME_CLIENT_ID }}
          CHROME_CLIENT_SECRET: ${{ secrets.CHROME_CLIENT_SECRET }}
          CHROME_REFRESH_TOKEN: ${{ secrets.CHROME_REFRESH_TOKEN }}
          FIREFOX_EXTENSION_ID: ${{ secrets.FIREFOX_EXTENSION_ID }}
          FIREFOX_JWT_ISSUER: ${{ secrets.FIREFOX_JWT_ISSUER }}
          FIREFOX_JWT_SECRET: ${{ secrets.FIREFOX_JWT_SECRET }}
The action above lays the foundation for a basic workflow, including zip and submit steps. To further enhance your GitHub Action and delve into more complex scenarios, consider exploring the following examples from real projects. They introduce advanced features such as version management, changelog generation, and GitHub releases, tailored for different needs:

aklinker1/github-better-line-counts - Conventional commits, automated version bump and changelog generation, triggered manually, optional dry run for testing
GuiEpi/plex-skipper - Triggered automatically when package.json version is changed, creates and uploads artifacts to GitHub release.
These examples are designed to provide clear insights and are a good starting point for customizing your own workflows. Feel free to explore and adapt them to your project needs.

Stores
Chrome Web Store
✅ Supported • Developer Dashboard • Publishing Docs

To create a ZIP for Chrome:


wxt zip
Firefox Addon Store
✅ Supported • Developer Dashboard • Publishing Docs

Firefox requires you to upload a ZIP of your source code. This allows them to rebuild your extension and review the code in a readable way. More details can be found in Firefox's docs.

When running wxt zip -b firefox, WXT will zip both your extension and sources. Certain files (such as config files, hidden files, and tests) are automatically excluded from your sources. However, it's important to manually check the ZIP to ensure it only contains the files necessary to rebuild your extension.

To customize which files are zipped, add the zip option to your config file.


// wxt.config.ts
import { defineConfig } from 'wxt';

export default defineConfig({
  zip: {
    // ...
  },
});
If it's your first time submitting to the Firefox Addon Store, or if you've updated your project layout, always test your sources ZIP! The commands below should allow you to rebuild your extension from inside the extracted ZIP.


pnpm

npm

yarn

bun

pnpm i
pnpm zip:firefox
Ensure that you have a README.md or SOURCE_CODE_REVIEW.md file with the above commands so that the Firefox team knows how to build your extension.

Make sure the build output is the exact same when running wxt build -b firefox in your main project and inside the zipped sources.

WARNING

If you use a .env files, they can affect the chunk hashes in the output directory. Either delete the .env file before running wxt zip -b firefox, or include it in your sources zip with the zip.includeSources option. Be careful to not include any secrets in your .env files.

See Issue #377 for more details.

Private Packages
If you use private packages and you don't want to provide your auth token to the Firefox team during the review process, you can use zip.downloadPackages to download any private packages and include them in the zip.


// wxt.config.ts
export default defineConfig({
  zip: {
    downloadPackages: [
      '@mycompany/some-package',
      //...
    ],
  },
});
Depending on your package manager, the package.json in the sources zip will be modified to use the downloaded dependencies via the overrides or resolutions field.

WARNING

WXT uses the command npm pack <package-name> to download the package. That means regardless of your package manager, you need to properly setup a .npmrc file. NPM and PNPM both respect .npmrc files, but Yarn and Bun have their own ways of authorizing private registries, so you'll need to add a .npmrc file.

Safari
🚧 Not supported yet

WXT does not currently support automated publishing for Safari. Safari extensions require a native MacOS or iOS app wrapper, which WXT does not create yet. For now, if you want to publish to Safari, follow this guide:

Converting a web extension for Safari - "Convert your existing extension to a Safari web extension using Xcode’s command-line tool."
When running the safari-web-extension-converter CLI tool, pass the .output/safari-mv2 or .output/safari-mv3 directory, not your source code directory.


pnpm wxt build -b safari
xcrun safari-web-extension-converter .output/safari-mv2
Edge Addons
✅ Supported • Developer Dashboard • Publishing Docs

No need to create a specific ZIP for Edge. If you're already publishing to the Chrome Web Store, you can reuse your Chrome ZIP.

However, if you have features specifically for Edge, create a separate ZIP with:


wxt zip -b edge
Edit this page
Last updated: 10/18/24, 7:28 AM

Testing Updates
Testing Permission Changes
When permissions/host_permissions change during an update, depending on what exactly changed, the browser will disable your extension until the user accepts the new permissions.

You can test if your permission changes will result in a disabled extension:

Chromium: Use Google's Extension Update Testing tool
Firefox: See their Test Permission Requests page
Safari: Everyone breaks something in production eventually... 🫡 Good luck soldier
Update Event
You can setup a callback that runs after your extension updates like so:


browser.runtime.onInstalled.addListener(({ reason }) => {
  if (reason === 'update') {
    // Do something
  }
});
If the logic is simple, write a unit test to cover this logic. If you feel the need to manually test this callback, you can either:

In dev mode, remove the if statement and reload the extension from chrome://extensions
Use Google's Extension Update Testing tool
Edit this page
Last updated: 10/18/24, 7:28 AM